{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf370
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red100\green56\blue32;\red196\green26\blue22;
\red170\green13\blue145;\red92\green38\blue153;\red38\green71\blue75;\red63\green110\blue116;\red46\green13\blue110;
\red28\green0\blue207;\red14\green14\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 PhysicsLayer:\
\
\pard\tx529\pardeftab529\pardirnatural

\f1\fs22 \cf2 \CocoaLigature0 //\cf0 \
\cf2 //  PhysicsLayer.m\cf0 \
\cf2 //  Team1Game3\cf0 \
\cf2 //\cf0 \
\cf2 //  Created by Michelle Chesley, Priya Donti, Claire Murphy, and Carson Ramsden on 3/8/13.\cf0 \
\cf2 //\cf0 \
\cf2 //\cf0 \
\
\
\cf2 // NOTES:\cf0 \
\cf2 // CCTouchEnded: make sure to do bounds checking here so ball is not added in inventory\cf0 \
\
\cf3 #import \cf4 "PhysicsLayer.h"\cf3 \
#import \cf4 "InventoryLayer.h"\cf3 \
\cf0 \
\cf3 #import \cf4 "PhysicsSprite.h"\cf3 \
#import \cf4 "QueryCallback.h"\cf3 \
\cf0 \
\cf2 //#define DEBUG_DRAW 1;\cf0 \
\
\cf5 @implementation\cf0  PhysicsLayer\
\
\cf5 @synthesize\cf0  objectTag;\
\
\cf2 //-----INITIALIZATION-----//\cf0 \
\
-(\cf5 id\cf0 ) initWithObjects:(\cf6 NSArray\cf0  *)objects\
\{\
    \cf3 NSAssert1\cf0 (objects, \cf4 @"Objects array %@ given to PhysicsLayer is null."\cf0 , objects);\
    \
	\cf5 if\cf0 ( (\cf5 self\cf0 =[\cf5 super\cf0  \cf7 init\cf0 ])) \{\
		\
        \
        \cf8 _createdObjects\cf0  = [\cf6 NSMutableArray\cf0  \cf9 array\cf0 ];\
        \
        \
		\cf2 // enable events\cf0 \
		\cf5 self\cf0 .\cf8 isTouchEnabled\cf0  = \cf5 YES\cf0 ;\
		\cf5 self\cf0 .\cf8 isAccelerometerEnabled\cf0  = \cf5 YES\cf0 ;\
		\cf6 CGSize\cf0  superSize = [\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ].\cf7 winSize\cf0 ;\
        \
        [\cf5 self\cf0  \cf9 setContentSize\cf0 :\cf9 CGSizeMake\cf0 (superSize.\cf6 width\cf0 *\cf10 0.75\cf0 , superSize.\cf6 height\cf0 )];\
        [\cf5 self\cf0  \cf9 setPosition\cf0 :\cf3 ccp\cf0 (superSize.\cf6 width\cf0 *\cf10 0.25\cf0 , \cf10 0\cf0 )];\
        \
		\cf2 // init physics\cf0 \
        \cf8 b2Vec2\cf0  gravity;\
        gravity.\cf7 Set\cf0 (\cf10 0.0f\cf0 , -\cf10 10.0f\cf0 );\
        \cf8 _world\cf0  = \cf5 new\cf0  \cf8 b2World\cf0 (gravity);\
        _worldManager = [[WorldManager alloc] initWithWorld:_world andSize:[\cf5 self\cf0  contentSize] andPosition:[\cf5 self\cf0  position]];\
		[_worldManager initPhysics];\
        \cf8 _contactListener\cf0  = \cf5 new\cf0  \cf8 ContactListener\cf0 ();\
        \
		\cf8 _objectFactory\cf0  = [\cf8 ObjectFactory\cf0  \cf7 sharedObjectFactory\cf0 ];\
        \
        \cf8 _initialObjects\cf0  = objects;\
        \
        \cf8 _objectArray\cf0  = \cf5 NULL\cf0 ;\
        \
        \cf8 _trash\cf0  = \cf5 NULL\cf0 ;\
        \
        \cf8 _objectType\cf0  = [[\cf6 NSString\cf0  \cf9 alloc\cf0 ] \cf9 initWithFormat\cf0 :\cf4 @"None"\cf0 ];\
        \
        [\cf5 self\cf0  \cf7 addInitialObjects\cf0 ];\
		\
		[\cf5 self\cf0  \cf7 scheduleUpdate\cf0 ];\
        \
        \cf8 _editMode\cf0  = \cf5 YES\cf0 ;\
        \
        \cf8 _moveableDynamicStatus\cf0  = [[\cf6 NSMutableArray\cf0  \cf9 alloc\cf0 ] \cf9 init\cf0 ];\
        \
        \
        [_worldManager setContactListener:_contactListener andObjectFactory:_objectFactory andSize:[\cf5 self\cf0  contentSize]];\
	\}\
	\cf5 return\cf0  \cf5 self\cf0 ;\
\}\
\
-(\cf5 void\cf0 ) initPhysics\
\{\
	\
	\cf6 CGSize\cf0  size = [\cf5 self\cf0  \cf7 contentSize\cf0 ];\
	\
	\cf8 b2Vec2\cf0  gravity;\
	gravity.\cf7 Set\cf0 (\cf10 0.0f\cf0 , -\cf10 10.0f\cf0 );\
	\cf8 _world\cf0  = \cf5 new\cf0  \cf8 b2World\cf0 (gravity);\
	\
	\cf2 // Do we want to let bodies sleep?\cf0 \
	\cf8 _world\cf0 ->\cf7 SetAllowSleeping\cf0 (\cf5 true\cf0 );\
	\
	\cf8 _world\cf0 ->\cf7 SetContinuousPhysics\cf0 (\cf5 true\cf0 );\
    \
    \cf2 // For collision callbacks\cf0 \
    \cf8 _contactListener\cf0  = \cf5 new\cf0  \cf8 ContactListener\cf0 ();\
    \cf8 _world\cf0 ->\cf7 SetContactListener\cf0 (\cf8 _contactListener\cf0 );\
	\
	\cf8 m_debugDraw\cf0  = \cf5 new\cf0  \cf8 GLESDebugDraw\cf0 ( \cf3 PTM_RATIO\cf0  );\
    \
\cf2 //#ifdef DEBUG_DRAW\cf0 \
	\cf8 _world\cf0 ->\cf7 SetDebugDraw\cf0 (\cf8 m_debugDraw\cf0 );\
\cf2 //#endif\cf0 \
	\
	\cf8 uint32\cf0  flags = \cf10 0\cf0 ;\
	flags += \cf8 b2Draw\cf0 ::\cf7 e_shapeBit\cf0 ;\
	\cf8 m_debugDraw\cf0 ->\cf7 SetFlags\cf0 (flags);\
	\
	\cf2 // Define the ground body.\cf0 \
	\cf8 b2BodyDef\cf0  groundBodyDef;\
	groundBodyDef.\cf8 position\cf0 .\cf7 Set\cf0 (\cf10 0\cf0 , \cf10 0\cf0 ); \cf2 // bottom-left corner\cf0 \
	\
	\cf2 // Call the body factory which allocates memory for the ground body\cf0 \
	\cf2 // from a pool and creates the ground box shape (also from a pool).\cf0 \
	\cf2 // The body is also added to the world.\cf0 \
	\cf8 b2Body\cf0 * groundBody = \cf8 _world\cf0 ->\cf7 CreateBody\cf0 (&groundBodyDef);\
	\
	\cf2 // Define the ground box shape.\cf0 \
	\cf8 b2EdgeShape\cf0  groundBox;\
	\
	\cf2 // bottom\cf0 \
	groundBox.\cf7 Set\cf0 (\cf8 b2Vec2\cf0 (\cf10 0\cf0 ,\cf10 0\cf0 ), \cf8 b2Vec2\cf0 (size.\cf6 width\cf0 /\cf3 PTM_RATIO\cf0 ,\cf10 0\cf0 ));\
	groundBody->\cf7 CreateFixture\cf0 (&groundBox,\cf10 0\cf0 );\
	\
	\cf2 // top\cf0 \
	groundBox.\cf7 Set\cf0 (\cf8 b2Vec2\cf0 (\cf10 0\cf0 ,size.\cf6 height\cf0 /\cf3 PTM_RATIO\cf0 ), \cf8 b2Vec2\cf0 (size.\cf6 width\cf0 /\cf3 PTM_RATIO\cf0 ,size.\cf6 height\cf0 /\cf3 PTM_RATIO\cf0 ));\
	groundBody->\cf7 CreateFixture\cf0 (&groundBox,\cf10 0\cf0 );\
	\
	\cf2 // left\cf0 \
	groundBox.\cf7 Set\cf0 (\cf8 b2Vec2\cf0 (\cf10 0\cf0 ,size.\cf6 height\cf0 /\cf3 PTM_RATIO\cf0 ), \cf8 b2Vec2\cf0 (\cf10 0\cf0 ,\cf10 0\cf0 ));\
	groundBody->\cf7 CreateFixture\cf0 (&groundBox,\cf10 0\cf0 );\
	\
	\cf2 // right\cf0 \
	groundBox.\cf7 Set\cf0 (\cf8 b2Vec2\cf0 (size.\cf6 width\cf0 /\cf3 PTM_RATIO\cf0 ,size.\cf6 height\cf0 /\cf3 PTM_RATIO\cf0 ), \cf8 b2Vec2\cf0 (size.\cf6 width\cf0 /\cf3 PTM_RATIO\cf0 ,\cf10 0\cf0 ));\
	groundBody->\cf7 CreateFixture\cf0 (&groundBox,\cf10 0\cf0 );\
    \
    \
    \cf2 /* hacked default ramps\
     * ---------------------------------------------------------------------- */\cf0 \
    \
    \cf2 // Starting ramp\cf0 \
    \cf8 b2BodyDef\cf0  rampBodyDef;\
    rampBodyDef.\cf8 position\cf0 .\cf7 Set\cf0 (\cf10 0\cf0 /\cf3 PTM_RATIO\cf0 ,\cf10 100\cf0 /\cf3 PTM_RATIO\cf0 );\
    \
    \cf8 b2Body\cf0  *rampBody = \cf8 _world\cf0 ->\cf7 CreateBody\cf0 (&rampBodyDef);\
    \cf8 b2EdgeShape\cf0  rampEdge;\
    \cf8 b2FixtureDef\cf0  rampShapeDef;\
    rampShapeDef.\cf8 shape\cf0  = &rampEdge;\
    \
    \cf2 // ramp definitions\cf0 \
    rampEdge.\cf7 Set\cf0 (\cf8 b2Vec2\cf0 (\cf10 0\cf0 /\cf3 PTM_RATIO\cf0 ,\cf10 450\cf0 /\cf3 PTM_RATIO\cf0 ), \cf8 b2Vec2\cf0 (size.\cf6 width\cf0 /(\cf10 5\cf0 *\cf3 PTM_RATIO\cf0 ), \cf10 410\cf0 /\cf3 PTM_RATIO\cf0 ));\
    rampBody->\cf7 CreateFixture\cf0 (&rampShapeDef);\
    \
\}\
\
- (\cf5 void\cf0 ) addInitialObjects\
\{\
    \cf5 for\cf0  (\cf6 NSArray\cf0 * item \cf5 in\cf0  \cf8 _initialObjects\cf0 ) \{\
        \cf6 NSString\cf0 * type = [item \cf9 objectAtIndex\cf0 :\cf10 0\cf0 ];\
        \cf6 CGFloat\cf0  px = [[item \cf9 objectAtIndex\cf0 :\cf10 1\cf0 ] \cf9 floatValue\cf0 ];\
        \cf6 CGFloat\cf0  py = [[item \cf9 objectAtIndex\cf0 :\cf10 2\cf0 ] \cf9 floatValue\cf0 ];\
        \cf6 CGFloat\cf0  rotation = [[item \cf9 objectAtIndex\cf0 :\cf10 3\cf0 ] \cf9 floatValue\cf0 ];\
        [\cf5 self\cf0  \cf7 addNewSpriteOfType\cf0 :type \cf9 AtPosition\cf0 :\cf3 ccp\cf0 (px,py) \cf7 WithRotation\cf0 :rotation \cf7 AsDefault\cf0 :\cf5 YES\cf0 ];\
        \cf5 if\cf0  ([type \cf9 isEqual\cf0 : \cf4 @"RedPortalObject"\cf0 ])\
        \{\
            \cf8 _ballStartingPoint\cf0  = \cf9 CGPointMake\cf0 (px,py);\
        \}\
    \}\
\}\
\
\cf2 //-----GAME METHODS-----//\cf0 \
\
-(\cf5 void\cf0 ) addNewSpriteOfType: (\cf6 NSString\cf0 *) type AtPosition:(\cf6 CGPoint\cf0 )p WithRotation: (\cf6 CGFloat\cf0 ) rotation AsDefault:(\cf5 bool\cf0 )isDefault;\
\{\
    \cf5 if\cf0 ([type \cf9 isEqualToString\cf0 :\cf4 @"SeesawObject"\cf0 ])\
        \cf9 NSLog\cf0 (\cf4 @"SeesawObject"\cf0 );\
    \
    \cf3 NSAssert1\cf0 (\cf9 NSClassFromString\cf0 (type), \cf4 @"Type %@ given to addNewSpriteOfType in PhysicsLayer is not a valid object type"\cf0 , type);\
    \
    \cf2 // MULTI: add an if statement if there are multiple bodies in your object\cf0 \
    \cf6 NSArray\cf0  *spriteArray = [\cf6 NSArray\cf0  \cf9 array\cf0 ];\
    \cf5 if\cf0  ([type \cf9 isEqualToString\cf0 :\cf4 @"SeesawObject"\cf0 ])\
    \{\
        \cf8 PhysicsSprite\cf0 * sprite1 = [\cf8 PhysicsSprite\cf0  \cf7 spriteWithFile\cf0 :[\cf6 NSString\cf0  \cf9 stringWithFormat\cf0 :\cf4 @"%@Bottom.png"\cf0 , type]];\
        \cf8 PhysicsSprite\cf0 * sprite2 = [\cf8 PhysicsSprite\cf0  \cf7 spriteWithFile\cf0 :[\cf6 NSString\cf0  \cf9 stringWithFormat\cf0 :\cf4 @"%@Top.png"\cf0 , type]];\
        spriteArray = \cf10 @[\cf0 sprite1, sprite2\cf10 ]\cf0 ;\
    \} \cf5 else\cf0  \{\
        \cf8 PhysicsSprite\cf0 * sprite = [\cf8 PhysicsSprite\cf0  \cf7 spriteWithFile\cf0 :[\cf6 NSString\cf0  \cf9 stringWithFormat\cf0 :\cf4 @"%@.png"\cf0 ,type]];\
        spriteArray = \cf10 @[\cf0 sprite\cf10 ]\cf0 ;\
    \}\
    \
    \cf8 AbstractGameObject\cf0  *createdObj = [\cf8 _objectFactory\cf0  \cf7 objectFromString\cf0 :type \cf7 forWorld\cf0 :\cf8 _world\cf0  \cf7 asDefault\cf0 :isDefault \cf7 withSprites\cf0 :[spriteArray \cf9 mutableCopy\cf0 ]];\
    \
    [\cf8 _createdObjects\cf0  \cf9 addObject\cf0 :createdObj];\
    \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = [createdObj \cf9 createBody\cf0 :p];\
    \
    \
    \cf5 int\cf0  j = \cf10 0\cf0 ;\
    \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  b = bodies.\cf9 begin\cf0 (); b != bodies.\cf9 end\cf0 (); ++b)\
    \{\
        \cf8 PhysicsSprite\cf0 * s = [spriteArray \cf9 objectAtIndex\cf0 :j];\
        \cf8 b2Body\cf0 * body = *b;\
        [\cf5 self\cf0  \cf7 addChild\cf0 :s];\
        [s \cf7 setPhysicsBody\cf0 :body];\
        [s \cf9 setPosition\cf0 : \cf3 ccp\cf0 (body->\cf7 GetPosition\cf0 ().\cf8 x\cf0 , body->\cf7 GetPosition\cf0 ().\cf8 y\cf0 )];\
        body->\cf7 SetTransform\cf0 (\cf8 b2Vec2\cf0 (p.\cf6 x\cf0 /\cf3 PTM_RATIO\cf0 ,p.\cf6 y\cf0 /\cf3 PTM_RATIO\cf0 ), rotation);\
        ++j;\
    \}\
    \
    \cf8 b2Body\cf0 * theBody = *(bodies.\cf9 begin\cf0 ());\
    \cf5 if\cf0  (![((\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(theBody->\cf7 GetUserData\cf0 ())).\cf8 _tag\cf0  \cf9 isEqualToString\cf0 :\cf4 @"BallObject"\cf0 ])\
    \{\
        \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  b = bodies.\cf9 begin\cf0 (); b != bodies.\cf9 end\cf0 (); ++b)\
        \{\
            \cf8 b2Body\cf0 * body = *b;\
            \cf8 b2Fixture\cf0 * f = body->\cf7 GetFixtureList\cf0 ();\
            \cf8 b2PolygonShape\cf0 * polygonShape = (\cf8 b2PolygonShape\cf0 *)f->\cf7 GetShape\cf0 ();\
            \cf5 int\cf0  count = polygonShape->\cf7 GetVertexCount\cf0 ();\
            \
            \cf6 CGFloat\cf0  offset = \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 origin\cf0 .\cf6 x\cf0 ;\
            \
            \cf5 for\cf0 (\cf5 int\cf0  i = \cf10 0\cf0 ; i < count; i++)\
            \{\
                \cf6 CGFloat\cf0  xCoordinate =(\cf6 CGFloat\cf0 ) (&polygonShape->\cf7 GetVertex\cf0 (i))->\cf8 x\cf0 ;\
                \cf6 CGFloat\cf0  yCoordinate = (\cf6 CGFloat\cf0 ) (&polygonShape->\cf7 GetVertex\cf0 (i))->\cf8 y\cf0 ;\
                \cf6 CGPoint\cf0  point = \cf7 ccpMult\cf0 (\cf9 CGPointMake\cf0 (xCoordinate, yCoordinate), \cf3 PTM_RATIO\cf0 );\
                \cf6 CGPoint\cf0  boundPoint = \cf9 CGPointMake\cf0 (point.\cf6 x\cf0  + p.\cf6 x\cf0  + offset, point.\cf6 y\cf0  + p.\cf6 y\cf0 );\
                boundPoint = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 : boundPoint];\
            \}\
        \}\
    \}\
\}\
\
-(\cf6 CGPoint\cf0 )getBallStartingPoint\
\{\
    \cf5 return\cf0  \cf8 _ballStartingPoint\cf0 ;\
\}\
\
-(\cf5 void\cf0 )playLevel\
\{\
    \cf5 if\cf0  (\cf8 _editMode\cf0 ) \{ \cf2 // So you can only do it once before resetting.\cf0 \
        \cf8 _editMode\cf0  = \cf5 NO\cf0 ;\
        [\cf5 self\cf0  \cf7 addNewSpriteOfType\cf0 :\cf4 @"BallObject"\cf0  \cf9 AtPosition\cf0 :\cf8 _ballStartingPoint\cf0  \cf7 WithRotation\cf0 :\cf10 0\cf0  \cf7 AsDefault\cf0 :\cf5 NO\cf0 ];\
    \}\
\}\
\
\
\cf2 // TODO: did not change this method for multi-body because BallObject and StarObject are single-body objects.  Change if necessary.\cf0 \
-(\cf5 void\cf0 ) resetBall\
\{\
    \cf2 // Delete Ball and Stars\cf0 \
    \cf5 for\cf0  (\cf8 b2Body\cf0 * b = \cf8 _world\cf0 ->\cf7 GetBodyList\cf0 (); b; b = b->\cf7 GetNext\cf0 ())\{\
        \cf5 if\cf0  ([((\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(b->\cf7 GetUserData\cf0 ())).\cf8 _tag\cf0  \cf9 isEqualToString\cf0 :\cf4 @"BallObject"\cf0 ])\
        \{\
            \cf8 AbstractGameObject\cf0 * a = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(b->\cf7 GetUserData\cf0 ());\
            \cf9 CFBridgingRetain\cf0 (a);\
            \cf8 CCSprite\cf0 * sprite = [[a \cf7 getSprites\cf0 ] \cf9 objectAtIndex\cf0 :\cf10 0\cf0 ];\
            [\cf5 self\cf0  \cf7 removeChild\cf0 : sprite \cf7 cleanup\cf0 :\cf5 NO\cf0 ]; \cf2 // cleanup removed\cf0 \
            [\cf5 self\cf0  \cf7 deleteObjectWithBody\cf0 :b];\
        \}\
        \
        \cf5 if\cf0  ([((\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(b->\cf7 GetUserData\cf0 ())).\cf8 _tag\cf0  \cf9 isEqualToString\cf0 :\cf4 @"StarObject"\cf0 ])\
        \{\
            \cf8 AbstractGameObject\cf0 * a = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(b->\cf7 GetUserData\cf0 ());\
            \cf9 CFBridgingRetain\cf0 (a);\
            \cf8 CCSprite\cf0 * sprite = [[a \cf7 getSprites\cf0 ] \cf9 objectAtIndex\cf0 :\cf10 0\cf0 ];\
            [\cf5 self\cf0  \cf7 removeChild\cf0 : sprite \cf7 cleanup\cf0 :\cf5 NO\cf0 ]; \cf2 // cleanup removed\cf0 \
            [\cf5 self\cf0  \cf7 deleteObjectWithBody\cf0 :b];\
        \}\
    \}\
    \cf2 // put back all the stars from the JSON file\cf0 \
    \cf5 for\cf0  (\cf6 NSArray\cf0 * item \cf5 in\cf0  \cf8 _initialObjects\cf0 ) \{\
        \cf6 NSString\cf0 * type = [item \cf9 objectAtIndex\cf0 :\cf10 0\cf0 ];\
        \cf5 if\cf0  ([type \cf9 isEqualToString\cf0 : \cf4 @"StarObject"\cf0 ])\
        \{\
            \cf6 CGFloat\cf0  px = [[item \cf9 objectAtIndex\cf0 :\cf10 1\cf0 ] \cf9 floatValue\cf0 ];\
            \cf6 CGFloat\cf0  py = [[item \cf9 objectAtIndex\cf0 :\cf10 2\cf0 ] \cf9 floatValue\cf0 ];\
            \cf6 CGFloat\cf0  rotation = [[item \cf9 objectAtIndex\cf0 :\cf10 3\cf0 ] \cf9 floatValue\cf0 ];\
            [\cf5 self\cf0  \cf7 addNewSpriteOfType\cf0 :type \cf9 AtPosition\cf0 :\cf3 ccp\cf0 (px,py) \cf7 WithRotation\cf0 :rotation \cf7 AsDefault\cf0 :\cf5 YES\cf0 ];\
        \}\
    \}\
    \cf2 // make level editable again\cf0 \
    \cf8 _editMode\cf0  = \cf5 YES\cf0 ;\
    \
\}\
\
\
\cf2 // TODO: did not change this method for multi-body because StarObject is single-body object.  Change if necessary.\cf0 \
\cf2 /* hitStar:\
 * removes star from screen when it is hit\
 */\cf0 \
-(\cf5 void\cf0 ) hitStar:(\cf8 b2Body\cf0 *) starBody\
\{\
    \cf3 NSAssert\cf0 (starBody, \cf4 @"Star body in hitStar in Physics Layer is null."\cf0 );\
    \
    \cf2 // delete the star sprite\cf0 \
    \cf8 AbstractGameObject\cf0 * starBodyObject = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(starBody->\cf7 GetUserData\cf0 ());\
    \cf9 CFBridgingRetain\cf0 (starBodyObject);\
    \cf8 CCSprite\cf0 * sprite = [[starBodyObject \cf7 getSprites\cf0 ] \cf9 objectAtIndex\cf0 :\cf10 0\cf0 ];\
    [\cf5 self\cf0  \cf7 removeChild\cf0 : sprite \cf7 cleanup\cf0 :\cf5 NO\cf0 ]; \cf2 //cleanup removed\cf0 \
    \
    \cf2 // delete the star body\cf0 \
    [_worldManager destroyBody:starBody];\
    \cf2 //_bodiesToDestroy.push_back(starBody);\cf0 \
    \
    [\cf5 self\cf0  \cf7 updateStarCount\cf0 ];\
\}\
\
\
-(\cf5 void\cf0 ) trampolineDraggable\
\{\
    \cf5 for\cf0  (\cf8 b2Body\cf0 * body = \cf8 _world\cf0 ->\cf7 GetBodyList\cf0 (); body; body = body->\cf7 GetNext\cf0 ())\
    \{\
        \
        \cf5 if\cf0  ([((\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(body->\cf7 GetUserData\cf0 ())).\cf8 _tag\cf0  \cf9 isEqualToString\cf0 :\cf4 @"TrampolineObject"\cf0 ])\
             \{\
                 \cf5 for\cf0  ( \cf8 b2Fixture\cf0 * f = body->\cf7 GetFixtureList\cf0 (); f; f = f->\cf7 GetNext\cf0 () ) \{\
                     \
                 \}\
             \}\
    \}\
\}\
\
-(\cf5 void\cf0 ) setTarget:(\cf5 id\cf0 ) sender atAction:(\cf5 SEL\cf0 )action\
\{\
    \cf3 NSAssert1\cf0 (sender, \cf4 @"Sender %@ for PhysicsLayer setTarget is null."\cf0 , sender);\
    \cf3 NSAssert\cf0 (action, \cf4 @"Selector for PhysicsLayer setTarget is null."\cf0 );\
    \
    \cf8 _target\cf0  = sender;\
    \cf5 if\cf0  (!\cf8 _selector1\cf0 ) \{\
        \cf8 _selector1\cf0  = action;\
    \}\
    \cf5 else\cf0  \cf5 if\cf0  (!\cf8 _selector2\cf0 ) \{\
        \cf8 _selector2\cf0  = action;\
    \}\
    \cf5 else\cf0  \cf5 if\cf0  (!\cf8 _selector3\cf0 )\
    \{\
        \cf8 _selector3\cf0  = action;\
    \}\
    \cf5 else\cf0  \cf5 if\cf0  (!\cf8 _selector4\cf0 )\
    \{\
        \cf8 _selector4\cf0  = action;\
    \}\
    \cf5 else\cf0 \
    \{\
        \cf8 _selector5\cf0  = action;\
    \}\
\}\
\
\cf2 /* gameWon:\
 * indicates the game is won when the ball hits the portal\
 */\cf0 \
-(\cf5 void\cf0 ) gameWon\
\{\
    [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector2\cf0 ];\
\}\
\
\cf2 /* updateStarCount:\
 * causes star count to be updated when a star is hit\
 */\cf0 \
-(\cf5 void\cf0 ) updateStarCount\
\{\
    [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector3\cf0 ];\
\}\
\
\cf2 /* getObjectType:\
 * gets type of object to be added to screen\
 */\cf0 \
- (\cf6 NSString\cf0 *) getObjectType\
\{\
    \cf5 return\cf0  [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector1\cf0 ];\
\}\
-(\cf5 void\cf0 ) objectDeletedOfType: (\cf6 NSString\cf0 *) type\
\{\
    [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector4\cf0  \cf9 withObject\cf0 :type];\
\}\
\
\
\cf2 // DONE: changed for multi-body\cf0 \
\cf2 /* deleteObjectWithBody:\
 * deletes a physics body from the physics layer\
 */\cf0 \
\
-(\cf5 void\cf0 ) deleteObjectWithBody: (\cf8 b2Body\cf0 *) body\
\{\
    \cf8 AbstractGameObject\cf0 * object = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(body->\cf7 GetUserData\cf0 ());\
    \
    \cf9 CFBridgingRetain\cf0 (object);\
\
    \
    \cf6 NSString\cf0 * objectType = object.\cf8 _tag\cf0 ;\
    [\cf5 self\cf0  \cf7 objectDeletedOfType\cf0 :objectType];\
    \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = object->\cf8 _bodies\cf0 ;\
 \
    \cf6 NSMutableArray\cf0 * objectSprites = [object \cf7 getSprites\cf0 ];\
    \
    \cf5 int\cf0  j=\cf10 0\cf0 ;\
    \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  b = bodies.\cf9 begin\cf0 (); b != bodies.\cf9 end\cf0 (); ++b)\
    \{\
        \cf8 PhysicsSprite\cf0 * s = [objectSprites \cf9 objectAtIndex\cf0 :j];\
        \cf8 b2Body\cf0 * body = *b;\
        [\cf5 self\cf0  \cf7 removeChild\cf0 :s \cf7 cleanup\cf0 :\cf5 NO\cf0 ]; \cf2 //cleanup removed\cf0 \
        [_worldManager destroyBody:body];\
        \cf2 //_bodiesToDestroy.push_back(body);\cf0 \
        ++j;\
    \}\
    \cf2 //NSLog(@"bodies destroyed successfully");\cf0 \
    [\cf8 _objectArray\cf0  \cf9 removeObject\cf0 :object];\
\}\
\
\cf2 //-----BUILT-IN/BOX 2D-----//\cf0 \
\
-(\cf5 void\cf0 ) draw\
\{\
	\cf2 //\cf0 \
	\cf2 // IMPORTANT:\cf0 \
	\cf2 // This is only for debug purposes\cf0 \
	\cf2 // It is recommended to disable it\cf0 \
	\cf2 //\cf0 \
	[\cf5 super\cf0  \cf7 draw\cf0 ];\
	\
	\cf7 ccGLEnableVertexAttribs\cf0 ( \cf7 kCCVertexAttribFlag_Position\cf0  );\
	\
	\cf7 kmGLPushMatrix\cf0 ();\
	\
    \cf2 //NOTE: can also comment this out to put back debug draw\cf0 \
	\cf8 _world\cf0 ->\cf7 DrawDebugData\cf0 ();\
	\
	\cf7 kmGLPopMatrix\cf0 ();\
\}\
\
\cf2 /* update:\
 * simulates a time step in the physics world\
 */\cf0 \
-(\cf5 void\cf0 ) update: (\cf8 ccTime\cf0 ) dt\
\{\
	\cf2 //It is recommended that a fixed time step is used with Box2D for stability\cf0 \
	\cf2 //of the simulation, however, we are using a variable time step here.\cf0 \
	\cf2 //You need to make an informed choice, the following URL is useful\cf0 \
	\cf2 //{\field{\*\fldinst{HYPERLINK "http://gafferongames.com/game-physics/fix-your-timestep/"}}{\fldrslt \cf11 http://gafferongames.com/game-physics/fix-your-timestep/}}\cf0 \
	\
	\cf8 int32\cf0  velocityIterations = \cf10 8\cf0 ;\
	\cf8 int32\cf0  positionIterations = \cf10 1\cf0 ;\
	\
	\cf2 // Instruct the world to perform a single step of simulation. It is\cf0 \
	\cf2 // generally best to keep the time step and iterations fixed.\cf0 \
	\cf8 _world\cf0 ->\cf7 Step\cf0 (dt, velocityIterations, positionIterations);\
    \
    \cf5 if\cf0  (\cf8 _contactListener\cf0 ->\cf8 _gameWon\cf0 ) \{\
        \cf8 _contactListener\cf0 ->\cf8 _gameWon\cf0  = \cf5 false\cf0 ;\
        [\cf5 self\cf0  \cf7 gameWon\cf0 ];\
    \}\
    \cf5 if\cf0  (\cf8 _contactListener\cf0 ->\cf8 _contactStar\cf0  != \cf5 NULL\cf0 ) \{\
        [\cf5 self\cf0  \cf7 hitStar\cf0 :(\cf8 _contactListener\cf0 ->\cf8 _contactStar\cf0 )];\
        \cf8 _contactListener\cf0 ->\cf8 _contactStar\cf0  = \cf5 NULL\cf0 ;\
    \}\
    \
    [_worldManager applyMagnets];\
    [_worldManager springSeesaw];\
    \
    [_worldManager update];\
\}\
\
\
\cf2 //-----TOUCHING WITH DRAGGING-----//\cf0 \
\
-(\cf5 void\cf0 )registerWithTouchDispatcher\
\{\
    [[[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf7 touchDispatcher\cf0 ] \cf7 addTargetedDelegate\cf0 :\cf5 self\cf0  \cf7 priority\cf0 :\cf10 0\cf0  \cf7 swallowsTouches\cf0 :\cf5 YES\cf0 ];\
\}\
\
-(\cf5 BOOL\cf0 )ccTouchBegan:(\cf6 UITouch\cf0  *)touch withEvent:(\cf6 UIEvent\cf0  *)event \{\
    \cf9 NSLog\cf0 (\cf4 @"Physics touch began"\cf0 );\
    \cf5 if\cf0  (\cf8 _firstTouch\cf0  == \cf5 NULL\cf0 ) \{\
        \cf9 NSLog\cf0 (\cf4 @"First touch"\cf0 );\
        \cf8 _firstTouch\cf0  = touch;\
        \
        \cf2 //Get tap location and convert to cocos2d-box2d coordinates\cf0 \
        \cf6 CGPoint\cf0  touchLocation = [touch \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]];\
        touchLocation = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 :touchLocation];\
        touchLocation = [\cf5 self\cf0  \cf9 convertToNodeSpace\cf0 :touchLocation];\
        \cf8 _initialTouchPosition\cf0  = \cf8 b2Vec2\cf0 (touchLocation.\cf6 x\cf0 /\cf3 PTM_RATIO\cf0 , touchLocation.\cf6 y\cf0 /\cf3 PTM_RATIO\cf0 );\
        \cf9 NSLog\cf0 ([[\cf6 NSString\cf0  \cf9 alloc\cf0 ] \cf9 initWithFormat\cf0 :\cf4 @"Physics touch location: %f, %f"\cf0 , touchLocation.\cf6 x\cf0 , touchLocation.\cf6 y\cf0 ]);\
        \
        \cf2 //If the touch is in the inventory, add an object where the touch is\cf0 \
        \cf5 if\cf0  (touchLocation.\cf6 x\cf0  < \cf10 0\cf0 ) \{\
            \cf9 NSLog\cf0 (\cf4 @"Touch in inventory"\cf0 );\
            \cf6 NSString\cf0 * type = [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector1\cf0 ];\
            \cf5 if\cf0  (![type \cf9 isEqualToString\cf0 :\cf4 @"None"\cf0 ]) \{\
                [\cf5 self\cf0  \cf7 addNewSpriteOfType\cf0 :type \cf9 AtPosition\cf0 :touchLocation \cf7 WithRotation\cf0 :\cf10 0.0\cf0  \cf7 AsDefault\cf0 :\cf5 false\cf0 ];\
            \}\
        \}\
        \
        \cf2 // Make a small box.\cf0 \
        \cf8 b2AABB\cf0  aabb;\
        \cf8 b2Vec2\cf0  d;\
        d.\cf7 Set\cf0 (\cf10 0.001f\cf0 , \cf10 0.001f\cf0 );\
        aabb.\cf8 lowerBound\cf0  = \cf8 _initialTouchPosition\cf0  - d;\
        aabb.\cf8 upperBound\cf0  = \cf8 _initialTouchPosition\cf0  + d;\
        \
        \cf2 // Query the world for overlapping shapes.\cf0 \
        \cf8 QueryCallback\cf0  callback(\cf8 _initialTouchPosition\cf0 );\
        \cf8 _world\cf0 ->\cf7 QueryAABB\cf0 (&callback, aabb);\
        \
\
        \
        \
        \cf8 b2Body\cf0 * body = callback.\cf8 m_object\cf0 ;\
        \
        \cf2 // Get the current info about the body\cf0 \
        \cf5 if\cf0  (body) \{\
            \cf8 AbstractGameObject\cf0 * bodyObject = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(body->\cf7 GetUserData\cf0 ());\
            \cf9 CFBridgingRetain\cf0 (bodyObject);\
            \
            \cf5 if\cf0  (!bodyObject->\cf8 _isDefault\cf0  && \cf8 _editMode\cf0 ) \{\
                \
                \cf8 _initialBodyPosition\cf0  = body->\cf7 GetPosition\cf0 ();\
                \
                \cf8 _currentMoveableBody\cf0  = body;\
                \
                [\cf8 _moveableDynamicStatus\cf0  \cf9 removeAllObjects\cf0 ];\
                \
                \cf5 if\cf0  (touchLocation.\cf6 x\cf0  > \cf10 0\cf0 ) \{\
                    \cf8 _trash\cf0  = [\cf8 CCSprite\cf0  \cf7 spriteWithFile\cf0 :\cf4 @"trash2.png"\cf0 ];\
                    \cf8 _trash\cf0 .\cf8 position\cf0  = \cf3 ccp\cf0 (-\cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 width\cf0 /\cf10 5.9\cf0 , \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 height\cf0 /\cf10 2\cf0 );\
                    [\cf5 self\cf0  \cf7 addChild\cf0 :\cf8 _trash\cf0  \cf7 z\cf0 :\cf10 10000\cf0 ];\
                \}\
                \
                \
                \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = bodyObject->\cf8 _bodies\cf0 ;\
                \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i) \{\
                    \cf8 b2Body\cf0 * loopBody = *i;\
                    \
                    \cf5 if\cf0  (loopBody->\cf7 GetType\cf0 () == \cf7 b2_dynamicBody\cf0 ) \{\
                        [\cf8 _moveableDynamicStatus\cf0  \cf9 addObject\cf0 :\cf4 @"dynamic"\cf0 ];\
                        loopBody->\cf7 SetType\cf0 (\cf7 b2_staticBody\cf0 );\
                    \} \cf5 else\cf0  \{\
                        [\cf8 _moveableDynamicStatus\cf0  \cf9 addObject\cf0 :\cf4 @"static"\cf0 ];\
                    \}\
                    \
                    loopBody->\cf7 SetActive\cf0 (\cf5 false\cf0 );\
                \}\
                \
            \cf2 // Clicking on the ball resets the ball\cf0 \
            \} \cf5 else\cf0  \cf5 if\cf0  ([bodyObject->\cf8 _tag\cf0  \cf9 isEqualToString\cf0 :\cf4 @"BallObject"\cf0 ]) \{\
                [\cf5 self\cf0  \cf7 resetBall\cf0 ];\
                [\cf8 _target\cf0  \cf9 performSelector\cf0 :\cf8 _selector5\cf0 ];\
            \}\
        \} \cf5 else\cf0  \cf5 if\cf0  (\cf8 _editMode\cf0 ) \{\
            \
            \cf2 //Add a new body/atlas sprite at the touched location\cf0 \
            \cf6 CGPoint\cf0  location = [touch \cf9 locationInView\cf0 : [touch \cf9 view\cf0 ]];\
            \cf5 if\cf0  (\cf9 CGRectContainsPoint\cf0 (\cf5 self\cf0 .\cf7 boundingBox\cf0 , location)) \{\
                location = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 : location];\
                location = [\cf5 self\cf0  \cf9 convertToNodeSpace\cf0 :location];\
                \
                \cf2 // get object type from inventory\cf0 \
                \cf8 _objectType\cf0  = [\cf5 self\cf0  \cf7 getObjectType\cf0 ];\
                \cf5 if\cf0 (\cf8 _objectType\cf0  && ![\cf8 _objectType\cf0  \cf9 isEqualToString\cf0 :\cf4 @"None"\cf0 ] && ![\cf8 _objectType\cf0  \cf9 isEqualToString\cf0 :\cf4 @"Delete"\cf0 ])\{\
                    [\cf5 self\cf0  \cf7 addNewSpriteOfType\cf0 :\cf8 _objectType\cf0  \cf9 AtPosition\cf0 :location \cf7 WithRotation\cf0 :\cf10 0\cf0  \cf7 AsDefault\cf0 :\cf5 NO\cf0 ];\
                \}\
            \}\
        \}\
    \} \cf5 else\cf0  \cf5 if\cf0  (\cf8 _secondTouch\cf0  == \cf5 NULL\cf0  && \cf8 _currentMoveableBody\cf0  != \cf5 NULL\cf0 ) \{\
        \cf8 _secondTouch\cf0  = touch;\
        \cf6 CGPoint\cf0  point = \cf7 ccpSub\cf0 ([\cf8 _secondTouch\cf0  \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]], [\cf8 _firstTouch\cf0  \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]]);\
        \cf6 CGPoint\cf0  xaxis = \cf9 CGPointMake\cf0 (-\cf10 1\cf0 , \cf10 0\cf0 );\
        \cf5 if\cf0  (point.\cf6 y\cf0  >= \cf10 0\cf0 ) \{\
            \cf8 _initialTouchAngle\cf0  = \cf7 ccpAngle\cf0 (point, xaxis);\
        \} \cf5 else\cf0  \{\
            point = \cf9 CGPointMake\cf0 (point.\cf6 x\cf0 , -point.\cf6 y\cf0 );\
            \cf8 _initialTouchAngle\cf0  = -\cf7 ccpAngle\cf0 (point, xaxis);\
        \}\
    \}\
    \cf5 return\cf0  \cf5 YES\cf0 ;\
\}\
\
-(\cf5 void\cf0 ) ccTouchMoved:(\cf6 UITouch\cf0  *)touch withEvent:(\cf6 UIEvent\cf0  *)event\
\{\
    \cf5 if\cf0  (\cf8 _currentMoveableBody\cf0  != \cf5 NULL\cf0 ) \{\
        \cf2 // If there's only one touch, drag\cf0 \
        \cf5 if\cf0  (touch == \cf8 _firstTouch\cf0  && \cf8 _secondTouch\cf0  == \cf5 NULL\cf0 ) \{\
            \cf2 // Calculate touch location\cf0 \
            \cf6 CGPoint\cf0  touchLocation = [touch \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]];\
            touchLocation = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 :touchLocation];\
            touchLocation = [\cf5 self\cf0  \cf9 convertToNodeSpace\cf0 :touchLocation];\
            \cf8 b2Vec2\cf0  location = \cf8 b2Vec2\cf0 (touchLocation.\cf6 x\cf0 /\cf3 PTM_RATIO\cf0 , touchLocation.\cf6 y\cf0 /\cf3 PTM_RATIO\cf0 );\
            \
            \cf2 // Move each body\cf0 \
            \cf8 AbstractGameObject\cf0 * bodyObject = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(\cf8 _currentMoveableBody\cf0 ->\cf7 GetUserData\cf0 ());\
            \cf9 CFBridgingRetain\cf0 (bodyObject);\
            \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = bodyObject->\cf8 _bodies\cf0 ;\
            \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i)\
            \{\
                \cf8 b2Body\cf0 * b = *i;\
                \cf8 b2Vec2\cf0  newPos = b->\cf7 GetPosition\cf0 () + (location - \cf8 _initialTouchPosition\cf0 );\
                b->\cf7 SetTransform\cf0 (newPos,b->\cf7 GetAngle\cf0 ());\
            \}\
            \
            \cf8 _initialTouchPosition\cf0  = location;\
        \}\
        \cf2 // If there are 2 touches, rotate\cf0 \
        \cf5 if\cf0  (\cf8 _secondTouch\cf0  != \cf5 NULL\cf0  && (touch == \cf8 _firstTouch\cf0  || touch == \cf8 _secondTouch\cf0 )) \{\
            \cf2 // Calculate angle\cf0 \
            \cf6 CGPoint\cf0  point = \cf7 ccpSub\cf0 ([\cf8 _secondTouch\cf0  \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]], [\cf8 _firstTouch\cf0  \cf9 locationInView\cf0 :[touch \cf9 view\cf0 ]]);\
            \cf6 CGPoint\cf0  xaxis = \cf9 CGPointMake\cf0 (-\cf10 1\cf0 , \cf10 0\cf0 );\
            \cf5 float\cf0  touchAngle;\
            \cf5 if\cf0  (point.\cf6 y\cf0  >= \cf10 0\cf0 ) \{\
                touchAngle = \cf7 ccpAngle\cf0 (point, xaxis);\
            \} \cf5 else\cf0  \{\
                point = \cf9 CGPointMake\cf0 (point.\cf6 x\cf0 , -point.\cf6 y\cf0 );\
                touchAngle = -\cf7 ccpAngle\cf0 (point, xaxis);\
            \}\
            \
            \cf2 // Rotate each body\cf0 \
            \cf8 AbstractGameObject\cf0 * bodyObject = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(\cf8 _currentMoveableBody\cf0 ->\cf7 GetUserData\cf0 ());\
                \cf9 CFBridgingRetain\cf0 (bodyObject);\
            \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = bodyObject->\cf8 _bodies\cf0 ;\
            \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i)\
            \{\
                \cf8 b2Body\cf0 * b = *i;\
                \cf5 float\cf0  newAngle = b->\cf7 GetAngle\cf0 () + (touchAngle - \cf8 _initialTouchAngle\cf0 );\
                b->\cf7 SetTransform\cf0 (b->\cf7 GetPosition\cf0 (),newAngle);\
            \}\
            \
            \cf8 _initialTouchAngle\cf0  = touchAngle;\
        \}\
    \}\
\}\
\
-(\cf5 void\cf0 )ccTouchCancelled:(\cf6 UITouch\cf0  *)touch withEvent:(\cf6 UIEvent\cf0  *)event \{\
    \cf5 if\cf0  (touch == \cf8 _firstTouch\cf0 ) \{\
        \cf8 _currentMoveableBody\cf0  = \cf5 NULL\cf0 ;\
        \cf8 _firstTouch\cf0  = \cf5 NULL\cf0 ;\
        \cf8 _secondTouch\cf0  = \cf5 NULL\cf0 ;\
    \} \cf5 else\cf0  \cf5 if\cf0  (touch == \cf8 _secondTouch\cf0 ) \{\
        \cf8 _secondTouch\cf0  = \cf5 NULL\cf0 ;\
    \}\
\}\
\
- (\cf5 void\cf0 )ccTouchEnded:(\cf6 UITouch\cf0  *)touch withEvent:(\cf6 UIEvent\cf0  *)event \{\
    \cf5 if\cf0  (touch == \cf8 _firstTouch\cf0 ) \{\
        \cf8 _firstTouch\cf0  = \cf5 NULL\cf0 ;\
        \cf8 _secondTouch\cf0  = \cf5 NULL\cf0 ;\
        [\cf5 self\cf0  \cf7 removeChild\cf0 :\cf8 _trash\cf0  \cf7 cleanup\cf0 :\cf5 NO\cf0 ]; \cf2 //cleanup removed\cf0 \
        \cf6 CGPoint\cf0  location = [touch \cf9 locationInView\cf0 : [touch \cf9 view\cf0 ]];\
        \
        \cf5 if\cf0  (\cf8 _currentMoveableBody\cf0  != \cf5 NULL\cf0 ) \{\
            location = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 : location];\
            location = [\cf5 self\cf0  \cf9 convertToNodeSpace\cf0 :location];\
            \
            \cf8 AbstractGameObject\cf0 * bodyObject = (\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(\cf8 _currentMoveableBody\cf0 ->\cf7 GetUserData\cf0 ());\
                \cf9 CFBridgingRetain\cf0 (bodyObject);\
            \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = bodyObject->\cf8 _bodies\cf0 ;\
            \
            \cf5 bool\cf0  objectModified = \cf5 false\cf0 ;\
            \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i)\
            \{\
                \cf8 b2Body\cf0 * body = *i;\
                \
                \cf8 b2Fixture\cf0 * f = body->\cf7 GetFixtureList\cf0 ();\
                \cf5 for\cf0  (f= body->\cf7 GetFixtureList\cf0 (); f != \cf5 NULL\cf0 ; f = f->\cf7 GetNext\cf0 ())\
                \{\
                \cf8 b2PolygonShape\cf0 * polygonShape = (\cf8 b2PolygonShape\cf0 *)f->\cf7 GetShape\cf0 ();\
                \cf5 int\cf0  count = polygonShape->\cf7 GetVertexCount\cf0 ();\
                \
                \cf6 CGFloat\cf0  offset = \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 origin\cf0 .\cf6 x\cf0 ;\
            \
                \
                \cf5 for\cf0 (\cf5 int\cf0  i = \cf10 0\cf0 ; i < count; i++)\
                \{\
                    \cf6 CGFloat\cf0  xCoordinate =(\cf6 CGFloat\cf0 ) (&polygonShape->\cf7 GetVertex\cf0 (i))->\cf8 x\cf0 ;\
                    \cf6 CGFloat\cf0  yCoordinate = (\cf6 CGFloat\cf0 ) (&polygonShape->\cf7 GetVertex\cf0 (i))->\cf8 y\cf0 ;\
                    \cf6 CGPoint\cf0  point = \cf7 ccpMult\cf0 (\cf9 CGPointMake\cf0 (xCoordinate, yCoordinate), \cf3 PTM_RATIO\cf0 );\
                    \cf6 CGPoint\cf0  boundPoint = \cf9 CGPointMake\cf0 (point.\cf6 x\cf0  + location.\cf6 x\cf0  + offset, point.\cf6 y\cf0  + location.\cf6 y\cf0 );\
                    boundPoint = [[\cf8 CCDirector\cf0  \cf7 sharedDirector\cf0 ] \cf9 convertToGL\cf0 : boundPoint];\
                    \
                    \cf5 if\cf0  ( !\cf9 CGRectContainsPoint\cf0 (\cf5 self\cf0 .\cf7 boundingBox\cf0 , boundPoint))\
                    \{\
                        \cf5 if\cf0  (boundPoint.\cf6 x\cf0  < \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 origin\cf0 .\cf6 x\cf0  && boundPoint.\cf6 y\cf0  > \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 height\cf0 /\cf10 5\cf0  && boundPoint.\cf6 y\cf0  < \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 height\cf0 *\cf10 4\cf0 /\cf10 5\cf0 )\
                        \{\
                            \cf9 NSLog\cf0 (\cf4 @"bound point is %f"\cf0 , boundPoint.\cf6 y\cf0 );\
                            \cf9 NSLog\cf0 (\cf4 @"boundingBox height is %f"\cf0 , \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 height\cf0 );\
                            \cf2 // add an array here to get the body from ?\cf0 \
                            \cf2 //[_objectArray addObject:body];\cf0 \
                            [\cf5 self\cf0  \cf7 deleteObjectWithBody\cf0 :body];\
                            objectModified = \cf5 true\cf0 ;\
                            \cf5 break\cf0 ;\
                        \}\cf5 else\cf0 \{\
                            [\cf5 self\cf0  \cf7 bounceBackObjectWithBody\cf0 :body];\
                            objectModified = \cf5 true\cf0 ;\
                            \cf9 NSLog\cf0 (\cf4 @"bound point is %f"\cf0 , boundPoint.\cf6 y\cf0 );\
                            \cf9 NSLog\cf0 (\cf4 @"boundingBox height is %f"\cf0 , \cf5 self\cf0 .\cf7 boundingBox\cf0 .\cf6 size\cf0 .\cf6 height\cf0 );\
                            \cf5 break\cf0 ;\
                            \cf9 NSLog\cf0 (\cf4 @"Body dragged into walls"\cf0 );\
                        \}\
                    \}\
                \
                    \
                    \cf8 b2Vec2\cf0  vertex = \cf8 b2Vec2\cf0 (xCoordinate + location.\cf6 x\cf0 /\cf3 PTM_RATIO\cf0 , yCoordinate + location.\cf6 y\cf0 /\cf3 PTM_RATIO\cf0 );\
\
                    \cf2 // Make a small box.\cf0 \
                    \cf8 b2AABB\cf0  aabb;\
                    \cf8 b2Vec2\cf0  d;\
                    \cf2 // TODO: if want less overlap, make bounding box bigger\cf0 \
                    d.\cf7 Set\cf0 (\cf10 10.0f\cf0 , \cf10 10.0f\cf0 );\
                    aabb.\cf8 lowerBound\cf0  = vertex - d;\
                    aabb.\cf8 upperBound\cf0  = vertex + d;\
                    \
                    \cf8 QueryCallback\cf0  callback(vertex);\
                    \cf8 _world\cf0 ->\cf7 QueryAABB\cf0 (&callback, aabb);\
                    \
                    \cf8 b2Body\cf0 * b = callback.\cf8 m_object\cf0 ;\
                    \
                    \cf5 if\cf0  (b && (b != body)) \{\
                        [\cf5 self\cf0  \cf7 bounceBackObjectWithBody\cf0 :body];\
                        objectModified = \cf5 true\cf0 ;\
                    \}\
                    \
                \}\
                \
                \cf5 if\cf0  (objectModified) \{\
                    \cf5 break\cf0 ;\
                \}\
                \
            \}\
            \
            \cf5 int\cf0  statusCounter = \cf10 0\cf0 ;\
            \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i)\
            \{\
                \cf8 b2Body\cf0 * body = *i;\
                \cf5 if\cf0  ([[\cf8 _moveableDynamicStatus\cf0  \cf9 objectAtIndex\cf0 :statusCounter] \cf9 isEqualToString\cf0 :\cf4 @"dynamic"\cf0 ])\
                \{\
                    body->\cf7 SetType\cf0 (\cf7 b2_dynamicBody\cf0 );\
                \}\
                body->\cf7 SetActive\cf0 (\cf5 true\cf0 );\
                ++statusCounter;\
            \}\
            \
            \cf8 _currentMoveableBody\cf0  = \cf5 NULL\cf0 ;\
        \}\
    \} \cf5 else\cf0  \cf5 if\cf0  (touch == \cf8 _secondTouch\cf0 ) \{\
        \cf8 _secondTouch\cf0  = \cf5 NULL\cf0 ;\
    \}\
\}\
\}\
\
-(\cf5 void\cf0 ) bounceBackObjectWithBody: (\cf8 b2Body\cf0 *) body\
\{\
    \cf8 b2Vec2\cf0  cmbPosition = \cf8 _currentMoveableBody\cf0 ->\cf7 GetPosition\cf0 ();\
    \cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *> bodies = ((\cf5 __bridge\cf0  \cf8 AbstractGameObject\cf0 *)(body->\cf7 GetUserData\cf0 ()))->\cf8 _bodies\cf0 ;\
    \cf5 for\cf0  (\cf6 std\cf0 ::\cf6 vector\cf0 <\cf8 b2Body\cf0 *>::\cf6 iterator\cf0  i = bodies.\cf9 begin\cf0 (); i != bodies.\cf9 end\cf0 (); ++i)\
    \{\
        \
        \cf2 // TODO: THIS IS WRONG RIGHT NOW\cf0 \
        \cf2 //NSLog(@"Body number %d", ++j);\cf0 \
        \cf8 b2Body\cf0 * body = *i;\
        \cf8 b2Vec2\cf0  bodyOffset = body->\cf7 GetPosition\cf0 () - cmbPosition;\
        body->\cf7 SetTransform\cf0 (\cf8 _initialBodyPosition\cf0  + bodyOffset, body->\cf7 GetAngle\cf0 ());\
    \}\
    \
\}\
\
\
\cf2 //-----DEALLOC-----//\cf0 \
\
-(\cf5 void\cf0 ) dealloc\
\{\
	\cf5 delete\cf0  \cf8 m_debugDraw\cf0 ;\
	\cf8 m_debugDraw\cf0  = \cf5 NULL\cf0 ;\
    \cf5 for\cf0  (\cf8 b2Body\cf0 * b = \cf8 _world\cf0 ->\cf7 GetBodyList\cf0 (); b; b = b->\cf7 GetNext\cf0 ())\
    \{\
        b->\cf7 SetAwake\cf0 (\cf5 false\cf0 );\
    \}\
    \
    \cf5 for\cf0  (\cf8 b2Body\cf0 * b = \cf8 _world\cf0 ->\cf7 GetBodyList\cf0 (); b; b = b->\cf7 GetNext\cf0 ())\
    \{\
        \cf8 _world\cf0 ->\cf7 DestroyBody\cf0 (b);\
    \}\
    \
    \cf5 delete\cf0  \cf8 _world\cf0 ;\
	\cf8 _world\cf0  = \cf5 NULL\cf0 ;\
    \
	\
\}\
\
\
\cf5 @end\cf0 \
}